import { NextResponse } from "next/server";
import { Resend } from "resend";

type AnyDict = Record<string, any>;

function toObjectFromForm(fd: FormData): AnyDict {
  const obj: AnyDict = {};
  for (const [k, v] of fd.entries()) obj[k] = typeof v === "string" ? v : (v as File).name;
  return obj;
}

async function parseBody(req: Request): Promise<AnyDict> {
  const ct = (req.headers.get("content-type") || "").toLowerCase();
  try {
    if (ct.includes("application/json")) return await req.json();
    if (ct.includes("application/x-www-form-urlencoded") || ct.includes("multipart/form-data")) {
      const fd = await req.formData();
      return toObjectFromForm(fd);
    }
  } catch {}
  try { return await req.json(); } catch {}
  try { const fd = await req.formData(); return toObjectFromForm(fd); } catch {}
  return {};
}

const esc = (s: string) =>
  String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");

function pickFirst(obj: AnyDict, keys: string[]): {value: string, used: string[]} {
  const used: string[] = [];
  for (const k of keys) {
    const v = obj?.[k];
    if (v !== undefined && v !== null && String(v).trim() !== "") {
      used.push(k);
      return { value: String(v).trim(), used };
    }
  }
  return { value: "", used };
}

function tableFromEntries(entries: [string, any][]) {
  const rows = entries.map(([k, v]) =>
    `<tr><td style="padding:6px 10px;border:1px solid #eee"><b>${esc(k)}</b></td><td style="padding:6px 10px;border:1px solid #eee">${esc(String(v))}</td></tr>`
  ).join("");
  return `<table style="border-collapse:collapse;border:1px solid #eee">${rows}</table>`;
}

export const runtime = "nodejs";

export async function POST(req: Request) {
  try {
    const data = await parseBody(req);

    // Нормализация ключевых полей
    const fullNamePick = pickFirst(data, ["fullName","name","fullname","full_name","full-name","full name"]);
    const emailPick    = pickFirst(data, ["email","mail","e-mail","e_mail"]);
    const tierPick     = pickFirst(data, ["tier","participation","level"]);
    const amountPick   = pickFirst(data, ["amount","btc","contribution","intended","value"]);
    const messagePick  = pickFirst(data, ["message","msg","comment","note"]);

    const fullName = fullNamePick.value;
    const email    = emailPick.value;
    const tier     = tierPick.value;
    const amount   = amountPick.value;
    const message  = messagePick.value;

    // Список использованных ключей, чтобы не дублировать в таблице
    const usedKeys = new Set<string>([
      ...fullNamePick.used, ...emailPick.used, ...tierPick.used, ...amountPick.used, ...messagePick.used,
      "hp", "consent"
    ]);

    // Собираем только дополнительные поля (если они вообще есть)
    const extras = Object.entries(data).filter(([k]) => !usedKeys.has(k));

    const apiKey = process.env.RESEND_API_KEY;
    if (!apiKey) return NextResponse.json({ ok:false, error:"Server email is not configured" }, { status:500 });

    const resend = new Resend(apiKey);
    const to   = process.env.TO_EMAIL   || "info@bitcoinpetertodd.com";
    const from = process.env.FROM_EMAIL || "no-reply@bitcoinpetertodd.com";

    // HTML письма без дубляжа
    let html = `
      <h2>New Whitelist Application</h2>
      <ul>
        <li><b>Full name:</b> ${esc(fullName || "—")}</li>
        <li><b>Email:</b> ${esc(email || "—")}</li>
        <li><b>Participation tier:</b> ${esc(tier || "—")}</li>
        <li><b>Intended contribution (BTC):</b> ${esc(amount || "—")}</li>
      </ul>
    `;
    if (message) {
      html += `
        <p><b>Message:</b></p>
        <pre style="white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace">${esc(message)}</pre>
      `;
    }
    if (extras.length) {
      html += `<h3 style="margin-top:16px">Additional fields</h3>${tableFromEntries(extras)}`;
    }
    html += '<p style="color:#888;font-size:12px">This message was generated by the website form.</p>';

    await resend.emails.send({
      from,
      to,
      subject: `New Whitelist Application — ${fullName || "Unknown"}${amount ? ` (${amount} BTC)` : ""}`,
      html,
      reply_to: email || undefined
    });

    // Нежёстко: подтверждение пользователю (если указал email)
    if (email) {
      await resend.emails.send({
        from,
        to: email,
        subject: "We received your whitelist application",
        html: "<p>Thanks! We have received your application and will reach out for KYC/AML and on-chain instructions.</p>"
      }).catch(() => {});
    }

    return NextResponse.json({ ok:true });
  } catch (e:any) {
    console.error("apply route error:", e);
    return NextResponse.json({ ok:false, error: e?.message || "Unknown error" }, { status:500 });
  }
}
